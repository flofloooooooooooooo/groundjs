<html>
	<head>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r71/three.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5.1/dat.gui.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/stats.js/r16/Stats.js"></script>
		<script src="https://dl.dropboxusercontent.com/u/3587259/Code/Threejs/OrbitControls.js"></script>
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/chroma-js/1.2.1/chroma.min.js"></script>
        
		
		<script src="./libs/EffectComposer.js"></script>
		<script src="./libs/RenderPass.js"></script>
		<script src="./libs/CopyShader.js"></script>
		<script src="./libs/ShaderPass.js"></script>
		<script src="./libs/MaskPass.js"></script>
	</head>
	<body>
		<script>
			var camera, scene, renderer, geometry, material, mesh,stats;
            
init();

/*function init() {
    var depth = 30;
    var width =30;
    var height = 30;
    var spacingX = 30;
    var spacingZ = 30;

    scene = new THREE.Scene();
    camera = new  THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 10000);

    renderer = new  THREE.WebGLRenderer();
    renderer.setClearColor(0x000000,1.0);
    renderer.setSize(window.innerWidth, window.innerHeight);
    render.shadowMapEnable=true;

    camera.position.x=8;
    camera.position.y=8;
    camera.position.z=8;
    camera.lookAt(scene.position);

    cameraControl = new  THREE.OrbitControls(camera);

    var geometry = new THREE.Geometry();
    //Vectrices
    for(var z=0;z<depth;z++)
    {
    for(var x=0;x<width;x++)
    {
        var vertex = new THREE.Vector3(x*spacingX,Math.random()*height,z*spacingZ);
        geometry.vertices.push(vertex);

        console.log(geometry);
    }
    }


    //Faces
    for(var z=0;z<depth-1;z++)
    {
    for(var x=0;x<width-1;x++)
    {
        var a = x+z*width;
        var b = (x+1) + (z*width);
        var c = x + ((z+1)*width);
        var d = (x+1) + ((z+1) * width);

        var face1 = new THREE.Face3(a,b,c);
        var face2 = new THREE.Face3(a,b,c);

        console.log(chroma.scale(getHighPoint(geometry,face1)));

          //*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*
         //*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!
        //*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*
        face1.color=new THREE.Color(chroma.scale(getHighPoint(geometry,face1)).colors(1));
        face2.color=new THREE.Color(chroma.scale(getHighPoint(geometry,face2)).colors(1));

        geometry.faces.push(face1);
        geometry.faces.push(face2);
    }
    }

    //compute the normals
    geometry.computeVertexNormals(true);
    geometry.computeFaceNormals();

    //setup the materials
    var mat = new THREE.MeshPhongMaterial();
    var vertexColors = THREE.FaceColors;
    mat.shading=THREE.NoShading;

    //create the mesh
    var groundMesh = new THREE.Mesh(geometry,mat);
    groundMesh.translateX(-width/1.5);
    groundMesh.translateZ(-depth/4);
    groundMesh.name='terrain';

    //scene.add(groundMesh);
    var terreTexture = THREE.ImageUtils.loadTexture("./planets/earthmap4k.jpg");
    var terreGeometry = new THREE.SphereGeometry(5, 32, 32)
    var terreMaterial = new THREE.MeshLambertMaterial({map:terreTexture});
    var terre = new THREE.Mesh(terreGeometry,terreMaterial);
    terre.name="terre";
    terre.castShadow = true;
    scene.add(terre);
    
    render();
}

function getHighPoint(input)
{
    return ['white','green','blue'];
}
  */          
function addControlGui(controlObject){
	var gui = new dat.GUI();
 gui.add(controlObject,'rotationSpeed',-0.01,0.01);
 gui.add(controlObject,'opacity',0.1,1);
 gui.addColor(controlObject,'color');
}
function init() {

    scene = new THREE.Scene();
		camera = new  THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 10000);
    
 renderer = new  THREE.WebGLRenderer();
    renderer.setClearColor(0x000000,1.0);
    renderer.setSize(window.innerWidth, window.innerHeight);
    render.shadowMapEnable=true;
    
   camera.position.x=15;
   camera.position.y=16;
   camera.position.z=13;
   camera.lookAt(scene.position);
   
   cameraControl = new  THREE.OrbitControls(camera);
  
  var terreTexture = THREE.ImageUtils.loadTexture("./planets/earthmap10k.jpg");
  var terreGeometry = new THREE.SphereGeometry(0.5, 32, 32)
  var terreMaterial = new THREE.MeshLambertMaterial({map:terreTexture});
  var terre = new THREE.Mesh(terreGeometry,terreMaterial);
 terre.name="terre";
 terre.castShadow = true;
 
   scene.add(terre);
   
   var luneTexture = THREE.ImageUtils.loadTexture("./planets/moonmap4k.jpg");
  var luneGeometry = new THREE.SphereGeometry(0.1, 32, 32)
  var luneMaterial = new THREE.MeshLambertMaterial({map:luneTexture});
  var lune = new THREE.Mesh(luneGeometry,luneMaterial);
 lune.name="lune";
 lune.castShadow = true;
  lune.position.x=1;
 
   scene.add(lune);
 
 var nuagesTexture = THREE.ImageUtils.loadTexture("./planets/earthhiresclouds4K.png");
  var nuagesGeometry = new THREE.SphereGeometry(0.51, 32, 32)
  var nuagesMaterial = new THREE.MeshLambertMaterial({
  map:nuagesTexture,
  side        : THREE.DoubleSide,
  opacity     : 0.8,
  transparent : true,
  depthWrite  : false,
  });
  var nuages = new THREE.Mesh(nuagesGeometry,nuagesMaterial);
 nuages.name="nuages";
 nuages.castShadow = true;

  scene.add( nuages);
  
  var spotLight = new THREE.SpotLight(0xffffff);
  spotLight.position.set(10,20,20);
  spotLight.shadowCameraNear=20;
  spotLight.shadowCameraFar=50;
  spotLight.castShadow=true;

  scene.add(spotLight);
  
  control = new function(){
	this.rotationSpeed = 0.005;
	this.opacity = 0.6;
	this.color = terreMaterial.color.getHex();
};
addControlGui(control);
addStatsObject();

   
   document.body.appendChild(renderer.domElement);
   
	 //renderer.render(scene, camera);
   render();
}

function addStatsObject()
{
stats = new Stats();
stats.setMode(0);

stats.domElement.style.position = 'absolute';
stats.domElement.style.left = '0px';
stats.domElement.style.top = '0px';

document.body.appendChild(stats.domElement);
}

function render()
{
    cameraControl.update();
    renderer.render(scene,camera);
    requestAnimationFrame(render);
    renderer.autoClear = false;
    //composer.render();
}

function handleResize()
{
camera.aspect=window.innerWidth/windows.innerHeight;
camera.updateProjectionMatrix();
render.setSize(window.innerWidth,window.innerHeight);
}




		</script>
	</body>
</html>